# 线程 - 更多细节

## 线程和信号

UNIX 信号模型是基于 UNIX 进程模型而设计的, 问世比 Pthreads 要早几十年. 自然而然, 信号与线程模型之间
存在一些明显的冲突.

信号与线程之间的差异意味着, 将二者结合使用将会非常复杂. 因此在设计多线程程序时, 应该尽量避免使用信
号.

## 线程和进程控制

- 线程和 exec()
  - **只要有任一线程调用了 exec() 系列函数, 那么整个进程都会被替换. 除了调用线程外的其他所有线程都会
    立即消失**! 没有任何线程会调用线程清理函数, 也不会针对线程特有数据调用析构函数. 该进程中所有互斥
    锁、条件变量等线程同步的数据都会消失. 调用 exec() 后, 调用线程的线程 ID 是未定义的.
- 线程和 fork()
  - **当多线程进程调用 fork() 时, 仅会将发起调用的线程复制到子进程中. 其他线程都会在子进程中消失**.
    也同样不会调用线程清理函数, 也不会针对线程特有数据调用析构函数.
  - 可能遇到的问题
    - 子进程中只有发起 fork() 调用的线程, 但是其他线程中的互斥锁、条件变量等线程同步数据仍然存在.
      这可能导致死锁等问题.
    - 子进程中的全局数据也可能处于损坏状态, 因为其他正在对其进行数据更新的线程在 fork() 时消失了.
    - 因为并未调用线程清理函数, 所以也可能会导致内存泄漏等问题.
- 线程与 exit()
  - **当调用 exit() 时, 会终止整个进程, 而不仅仅是调用线程**. 也不会调用线程清理函数, 也不会针对线
    程特有数据调用析构函数.)



## 线程实现模型

### 1:1 一对一模型(内核级线程)

NPTL 采用了这一模型. 在 1:1 模型中, 每个用户线程都映射到一个内核线程上.
内核负责调度线程, 所有线程同步操作也同样通过内核的系统调用来完成.

## M:1 多对一模型(用户级线程)

在多对一模型中, 多个用户线程映射到一个内核线程上. 

此模型的优点是:

- 线程非常轻量, 不依赖任何系统调用, 创建、销毁线程的开销都很小.
- 移植性好, 不依赖于具体的操作系统.

其缺点也很明显:

- 某一线程发起同步 I/O 操作卡住时, 会阻塞整个进程.
- 内核无法对线程进行调度, 也就无法利用多核 CPU.

Python 的线程模型就是采用了 M:1 模型, 其全局 GIL 也饱受诟病.

### M:N 多对多模型

在 M:N 模型中, 多个用户线程映射到多个内核线程上.

优点:

- 相比 M:1 模型, 可以充分利用多核 CPU.
- 相比 1:1 模型, 线程创建、销毁的开销更小.

Go 语言的协程实现就是采用了 M:N 模型.

