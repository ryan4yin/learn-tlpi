# 详述进程创建与执行

### 为什么说 `fork()` 是创建进程，而 `clone()` 是创建线程

> fork() 是系统调用, 而 clone() 是 glibc 基于 `sys_clone()` 系统调用的封装函数.

某种意义上, 对术语 "进程" 和 "线程" 的区分不过是在玩弄文字游戏而已. 从内核的角度来看, 它们都是 KSE
(Kernel Scheduling Entity, 内核调度实体), 区别在于它们与其他 KSE 之间对属性(虚拟内存、打开文件描述
符、对信号的处置、进程 ID 等)的共享程度不同.

一句话解释，进程之间的资源是独立的, 而**线程只是 Linux 中一类特殊的进程**, 线程之间能共享许多资源.

- 进程: fork() 调用创建的新进程复制(CoW 写时复制)了父进程的栈段、数据段和堆段, 只有文本段(代码)是共
  享的.
- 线程: clone() 函数可以通过 flags 参数来细粒度控制新建进程与父进程之间的资源共享程度.

**在使用 clone() 创建进程时, 进程之间共享的资源够越多, clone() 的执行速度就越快**, clone() 的性能通
常远高于 fork().

目前 Linux 上主流的线程实现 NPTL 就是基于 clone() 实现的, 它底层就是通过 clone() 来创建共享资源足够
多的进程, 以实现线程的功能.

虽然 NPTL 是 glibc 的一部分，但它与 Linux 内核紧密协作，以提供符合 POSIX 标准的线程功能。NPTL 的设计
旨在利用内核提供的线程能力，以实现高效和兼容的线程操作。这意味着 NPTL 的实现既是用户空间的（通过
glibc），也依赖于内核空间的特性。

后面的 29 - 33 章会江西讲解线程的使用及其底层实现.
