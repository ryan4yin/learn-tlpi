# 能力

传统的 UNIX 权限模型中有效 UID=0 的用户进程（root, super user) 能绕过几乎所有的权限检测，而其他用户进程则需要根据用户与组 ID 进行权限验证。

这样 all-or-nothing 的权限划分太过粗放，Linux 为了实现更细粒度的权限划分而推出了「Linux 能力模型」。

## 什么是能力？

能力（Capabilities）是 Linux 内核提供的一种机制，用于将超级用户的权限划分为多个独立的单元。每个能力代表一种特定的权限，例如修改系统时间、绑定低端口或加载内核模块。通过能力模型，进程可以被授予仅执行特定操作所需的权限，而无需拥有完整的 root 权限。

## 常见能力

以下是一些常见的能力及其作用：

- `CAP_CHOWN`：允许修改文件的所有者和组。
- `CAP_NET_BIND_SERVICE`：允许绑定到 1024 以下的端口。
- `CAP_SYS_TIME`：允许修改系统时间。
- `CAP_KILL`：允许发送信号给其他进程。
- `CAP_NET_ADMIN`：允许执行网络管理操作（如配置接口）。


完整的列表参见：

https://man7.org/linux/man-pages/man7/capabilities.7.html

## 能力的应用场景

能力模型在以下场景中非常有用：

1. **最小权限原则**：进程只需拥有完成任务所需的最小权限，减少安全风险。
2. **容器化环境**：在 Docker 或 Kubernetes 中，可以通过能力限制容器的权限。
3. **特权分离**：将高权限操作拆分为多个进程，每个进程仅拥有必要的权限。


## 进程的「许可能力集」与「有效能力集」

> 进程的能力集决定了其运行时权限。

在 Linux 中，每个进程都有三个能力集：
1. **许可能力集（Permitted Set）**：进程可以启用的能力上限。即使进程暂时丢弃了某些能力，只要它们在许可能力集中，进程仍可以重新启用它们。
2. **有效能力集（Effective Set）**：进程当前实际拥有的能力。内核会根据有效能力集进行权限检查。
3. **可继承能力集（Inheritable Set）**：定义了 exec() 调用可继承的能力集（fork 子进程继承父进程所有权限）

### 示例
假设一个进程需要绑定低端口（`CAP_NET_BIND_SERVICE`），但不需要其他 root 权限：
1. 启动时，进程的许可能力集包含 `CAP_NET_BIND_SERVICE`。
2. 有效能力集为空（默认情况下）。
3. 进程在绑定端口前，通过 `cap_set_proc()` 将 `CAP_NET_BIND_SERVICE` 添加到有效能力集。
4. 绑定完成后，进程可以丢弃该能力以降低风险。

## 文件的「许可能力集」与「有效能力集」

> 文件的能力集可以预设进程的能力，避免依赖 root 权限

可执行文件也可以关联能力集，这些能力会在文件被执行时影响新进程的能力：
1. **文件的许可能力集**：定义进程启动时允许的能力。
2. **文件的有效能力集**：定义进程启动时自动启用的能力。
3. **文件的可继承能力集**：其功能与进程的一致，定义了 exec() 调用可继承的能力集。

### 示例
为 `nginx` 赋予绑定低端口的能力：
```bash
sudo setcap 'cap_net_bind_service=+ep' /usr/sbin/nginx
```
- `cap_net_bind_service=+ep` 表示：
  - `+e`：将能力添加到有效能力集。
  - `+p`：将能力添加到许可能力集。
这样，`nginx` 启动时无需 root 权限即可绑定 80 端口。

### 查看文件能力
```bash
getcap /usr/sbin/nginx
```
输出示例：
```
/usr/sbin/nginx = cap_net_bind_service+ep
```

## 在 exec() 中转变进程能力

在 exec() 调用执行期间，内核会根据「进程的当前能力」以及「被执行的文件的能力集」来设置进程的新能力。

TODO 这里太复杂了，暂时不细究，跳过。

## 发现程序所需的最小能力集合

对于一个我们并不清楚实现的程序，如何知道它需要的能力是哪些，从而实践「最小权限原则」？

- 使用 strace 来检查哪些系统调用报错 EPERM，该错误表示缺乏所需能力。但该错误也可能由其他问题导致，所以并不精确。
- 使用 eBPF 等内核探针来监控所有的能力检查，输出相关信息。

