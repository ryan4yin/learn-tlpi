# 基本概念

## 2.3 用户和组

用户 ID:

- **UID 0**: root 超级用户，在系统中享有特权，其凌驾于系统的权限检查之上，可以做（几乎）任何事情。
- **UID 1 - 99**: 预留给某些系统的关键服务。
- **UID 100 - 999**: 系统用户，通常用于运行系统服务。
- **UID 1000 - Inf+**: 普通用户。
  - 因此 Docker 容器通常使用 1000 作为默认用户 ID。

### 相关配置文件

- `/etc/passwd`: 存储用户信息
  - 格式：`username:password:UID:GID:comment:home:shell`
  - 例如：`ryan:x:1000:100:Ryan Yin:/home/ryan:/run/current-system/sw/bin/bash`
  - 密码字段通常为 `x`，表明密码被加密存储在 `/etc/shadow` 中。
- `/etc/shadow`: 存储用户密码的加密哈希值
  - 格式：`username:password:lastchg:min:max:warn:inactive:expire:flag`
  - 例如：`ryan:$7$CUxxxxxxxxxx.:1::::::`
- `/etc/group`: 存储组信息
  - 格式：`groupname:password:GID:users`。group 通常不设密码，因此 `password` 通常使用 `x`.
  - 例如: `docker:x:998:ryan,docker`

## 2.4 文件权限

> NOTE: 文件的权限检查仅在系统调用时进行, 一旦进程获得了文件的文件描述符, 它就可以直接操作文件, 而不会再进行任何权限检查。

- 文件权限通常使用三个数字表示，例如 `750`。
  - 三个数字分别对应这三类用户的权限: **所有者、所属组、其他用户**。
  - `r` 表示读权限（值为 4），`w` 表示写权限（值为 2），`x` 表示执行权限（值为 1），使用这三个数字的和表示权限。
  - 例如 `750` 表示：所有者具有读、写、执行权限，所属组具有读、执行权限，其他用户无权限。
- 使用 `ls -l` 查看文件权限。
- 使用 `chmod` 修改文件权限。
- 对目录而言, 三个权限分别有不同含义
  - `r` 表示可以列出目录下的文件列表(list)
  - `w` 表示可以在目录下创建、删除文件
  - `x` 表示可以访问目录下的文件(access)
  - `r` 跟 `x` 是不太好理解的两个权限, 举例说明:
    - 如果只有 `r` 权限, 那么用户可以看到目录下的文件列表, 但无法访问这些文件的内容.
    - 如果只有 `x` 权限, 那么用户可以访问目录下的文件, 但必须提前知道文件名.

```bash
› /bin/ls -al /etc/
total 872
# d 表示这是一个目录
drwxr-xr-x  93 root  wheel    2976 Nov 18 00:19 .
drwxr-xr-x   6 root  wheel     192 Nov 13 00:58 ..
# - 开头表示这是个普通文件
-rw-r--r--   1 root  wheel     515 Oct 22 15:49 afpovertcp.cfg
drwxr-xr-x   7 root  wheel     224 Jan 27  2024 agenix
# l 开头表示这是一个符号链接
lrwxr-xr-x   1 root  wheel      15 Oct 22 15:49 aliases -> postfix/aliases
```

## 2.7 进程

进程是正在运行的程序实例的内存布局，逻辑上进程被分为如下几个段：

- **Text Segment**: 存储程序自身（机器代码）。只读，并且在所有进程之间共享。
- **Data Segment**: 存储全局变量与静态变量（关键是它们可变）。
- **Heap Segment**: 堆，存储动态分配的内存。
- **Stack Segment**: 栈，随着函数调用的进行而动态增长和收缩的内存区域，用于存储局部变量和函数调用信息。

此外, 当一个程序结束运行时,它用到的所有内存都会被释放(即使程序本身可能没有调用 free 释放堆内存).

### 进程状态

进程分为运行与终止两种状态，但还有一种特殊的状态：僵尸进程。

当一个进程终止时，内核会保留一段时间的进程信息，以便父进程查询子进程的退出状态。这段时间称为僵尸进程状态。
如果父进程没有及时查询子进程的退出状态，那么子进程的信息将一直保留在内核中，直到父进程退出，此时子进程的信息才会被释放。

因此，如果观察到长期存在的僵尸进程，通常是父进程没有正确处理子进程的退出状态。

大量的僵尸进程会占用系统资源，导致一个表面上正常运行的系统实际上性能不佳。

### 进程的用户与组

每个进程都有如下三类与之相关的用户和组属性：

1. 真实用户 ID 和真实组 ID：进程的创建者。子进程会继承父进程的真实用户 ID 和真实组 ID。
2. 有效用户 ID 和有效组 ID：用于权限检查。进程的有效用户 ID 和有效组 ID 可以在进程运行时动态变更，这赋予了进程更多的权限控制能力。
3. 补充组 ID：用来标识进程所属的额外组。
   - 真实组 ID 与有效组 ID 都只能有一个，如果需要进程同时属于多个组，又不希望将用户加入到这些组，那么就需要使用补充组 ID。
   - 常在对 Linux 服务做细粒度的权限控制时使用。

### Capabilities

为了提高安全性，Linux 引入了 capabilities 的概念，将 root 用户的权限分解为多个小权限，以便更细粒度地控制进程的权限。

### 其他进程类别

- init 进程：所有进程的祖先进程，其 PID 为 1，其无法被终止。目前几乎所有商业 Linux 发行版都使用 systemd 作为 init 进程。
- 守护进程：后台运行的进程，通常在系统启动时启动，不依赖于用户登录。

### 环境列表

每个进程都有一个环境列表，用于存储环境变量。环境变量是进程运行时的一种配置，可以通过 `env` 命令查看当前进程的环境变量。

环境列表的功能通常类似于程序的命令行参数，许多程序都可以通过环境变量或命令行参数来配置同一系列选项的值。

### 资源限制

> 此功能由 [pam_limits](https://linux.die.net/man/8/pam_limits) 模块提供。

每个进程都可以使用 Linux 系统调用 `setrlimit` 为自己消耗的各类资源设置一个上限，最常见的用途是设置进程的文件描述符上限。

这类限制分为软限制和硬限制，软限制是内核允许进程消耗的资源上限，硬限制是内核允许进程设置的资源上限。

资源限制又分类两个层级：

1. 系统级资源限制：适用于整个系统，通常使用 `/etc/security/limits.conf` 配置。可使用 `ulimit` 命令查看。
   - 该配置文件可以设置系统级别的资源限制（使用 `*` 表示所有用户），也可以设置用户级别的资源限制。
   - man 文档：<https://linux.die.net/man/5/limits.conf>
2. 进程级资源限制：适用于单个进程，使用 `setrlimit` 系统调用设置。

## 2.8 内存映射

内存映射是一种将文件或其他对象映射到进程的虚拟地址空间的技术，这样进程就可以像访问内存一样访问文件。

常见用途：

1. 用于共享内存：多个进程可以映射同一个文件，这样多个进程就可以共享数据。
2. 用于 I/O：将文件映射到内存，可以减少 I/O 操作的次数，提高性能。
3. 用于堆内存分配：glibc 的 `malloc` 函数通常使用内存映射技术来分配大块内存（大于 128K）。
4. ...

## 2.9 静态库和共享库

- 静态库：是以 `.a` 为后缀的一类 UNIX 目标库文件。
  - 在编译时链接器会从静态库中抽取所需模块，将其复制到最终的可执行文件中。
  - 优点：编译时链接，不依赖于运行时环境。
  - 缺点：编译出的可执行文件体积较大，占用磁盘空间与内存空间，且无法动态更新。
- 共享库：是以 `.so` 为后缀的一类 UNIX 共享库文件。
  - 在编译时，链接器只会在可执行文件中留下对共享库的引用。
    在运行时，动态链接器会根据其配置查找共享库，并在运行时将共享库链接到进程的地址空间中。
  - 优点：节省磁盘空间与内存空间，且可以动态更新。
  - 缺点：运行时链接，依赖于运行时环境，且很容易出现共享库版本冲突。

Go 语言仅支持静态链接，因此 Go 语言编译出的可执行文件体积较大，但好处是可以方便地将可执行文件部署到各类 Linux 发行版上。
这是 Go 语言得以在云原生领域被广泛应用的一个重要原因。


## 2.10 进程间通信及同步

Linux 提供了丰富的进程间通信（IPC）机制，包括：

- 信号：用于通知进程发生了某个事件。
- 管道：用于实现进程间的单向通信。
- 套接字：用于实现进程间的双向通信。
  - 它类似于网络套接字，也可在其上使用 HTTP 等应用层网络协议。
- 文件锁定：用于实现进程间的同步。
- 消息队列：用于实现进程间的消息传递。
- 信号量（semaphore）：用于实现进程间的操作同步。
- 共享内存：用于实现进程间的数据共享。

## 2.15 伪终端

伪终端是一对相互连接的虚拟终端设备，其中一个称为主设备（master），另一个称为从设备（slave）。

伪终端技术的应用场景：

- telnet/ssh 等远程登录工具。
- 容器技术、虚拟机技术等。
- 桌面的 GUI 终端模拟器，如 kitty.



